# Java


### Java 특징
* 객체 지향 프로그래밍 언어, 컴파일 언어
* JVM만 있으면 OS와 상관없이 동작 가능(운영체제에 독립적)
* 고성능(High Performance): 바이트 코드로 변환되어 실행
* 멀티 스레딩 지원
  
### JVM(Java Virtual Machine)
* 컴파일러를 통해 바이트 코드로 변환된 파일을 JVM에 로딩하여 실행
* Garbage Collection 수행 (메모리 관리)
* Class Loader: JVM 내(Runtime Data Area)로 Class 파일을 로드하고 링크
* Excution Engine: 메모리(Runtime Data Area)에 적재된 클래스들을 기계어로 변경해 실행
    * 인터프리터: 바이트 코드를 한줄씩 읽어 기계어로 변환
    * JIT 컴파일러: 반복되는 코드를 기계어로 변환해 캐싱 (-> 캐싱한 것을 바로 실행해 속도 향상)

### Java 프로그램 실행 과정
* JVM은 OS로부터 메모리(Runtime Data Area)를 할당받음
* 컴파일러(javac)가 소스코드(.java)를 읽어들여 바이트 코드(.class)로 변환
* Class Loader를 통해 Class 파일을 JVM 내의 Runtime Data Area에 로딩
* 로딩된 Class 파일을 Excution Engine을 사용해 해석 및 실행


### Garbage Collection이 필요한 이유
* 자바는 메모리를 명시적으로 해제하지 않기 때문에 GC를 통해서 필요없는 객체를 지움. 더이상 사용하지 않는 동적 할당된 메모리 블럭(heap)을 찾아 다시 사용 가능한 자원으로 회수



### OOP의 4가지 특징
추상화(Abstraction)
* 구체적인 사물들의 공통적인 특징을 파악해서 이를 하나의 개념(집합)으로 다루는 것

캡슐화(Encapsulation)
* 정보 은닉(information hiding): 필요가 없는 정보는 외부에서 접근하지 못하도록 제한하는 것
높은 응집도, 낮은 결합도를 유지하여 유연함과 유지보수성 증가

상속(Inheritance)
* 여러 개체들이 가진 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립시키는 과정

다형성(Polymorphism)
* 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력
* 오버라이딩(Overriding), 오버로딩(Overloading)

### 오버로딩과 오버라이딩의 차이(Overloading vs Overriding)
오버로딩(Overloading)
  * 두 메서드가 같은 이름을 갖고 있으나 인자의 수나 자료형이 다른 경우

오버라이딩(Overriding)
  * 상위 클래스의 메서드와 이름과 signature가 같은 함수를 하위 클래스에 재정의하는 것
  * 상속 관계에 있는 클래스 간에 같은 이름의 메서드를 정의

### java의 non-static 멤버와 static 멤버의 차이
non-static 멤버
  * 멤버는 객체마다 별도로 존재한다.
      * 인스턴스 멤버 라고 부른다.
  * 객체 생성 시에 멤버가 생성된다.
      * 객체가 생길 때 멤버도 생성된다.
      * 객체 생성 후 멤버 사용이 가능하다.
      * 객체가 사라지면 멤버도 사라진다.
  * 공유되지 않는다.
static 멤버
  * 멤버는 클래스당 하나가 생성된다.
    * 멤버는 객체 내부가 아닌 별도의 공간에 생성된다.
    * 클래스 멤버 라고 부른다.
  * 클래스 로딩 시에 멤버가 생성된다.
    * 객체가 생기기 전에 이미 생성된다.
    * 객체가 생기기 전에도 사용이 가능하다. (즉, 객체를 생성하지 않고도 사용할 수 있다.)
    * 객체가 사라져도 멤버는 사라지지 않는다.
    * 멤버는 프로그램이 종료될 때 사라진다.
  * 동일한 클래스의 모든 객체들에 의해 공유된다.
  
### Q. java의 main 메서드가 static인 이유
JVM은 인스턴스가 없는 클래스의 main()을 호출해야하기 때문에 static이어야 한다.

### Java의 final 키워드 (final/finally/finalize)
final
  * 변수나 메서드 또는 클래스가 '변경 불가능'하도록 만든다.
  
finally 
  * try/catch 블록이 종료될 때 항상 실행될 코드 블록을 정의하기 위해 사용한다.
  * finally는 선택적으로 try 혹은 catch 블록 뒤에 정의할 때 사용한다.
  * finally 블록은 예외가 발생하더라도 항상 실행된다.
      * 단, JVM이 try 블록 실행 중에 종료되는 경우는 제외한다.
  
finalize()
  * 개념: Garbage Collector가 더 이상의 참조가 존재하지 않는 객체를 메모리에서 삭제하겠다고 결정하는 순간 호출된다.
  * Object 클래스의 finalize() 메서드를 오버라이드해서 맞춤별 GC를 정의할 수 있다.
    * protected void finalize() throws Throwable { // 파일 닫기, 자원 반환 등등 }


### Call by Reference와 Call by Value의 차이
* Call by Reference (참조에 의한 호출)
    * 함수가 호출될 때, 메모리 공간 안에서는 함수를 위한 별도의 임시 공간이 생성, 인자로 전달되는 변수의 레퍼런스를 전달한다. (해당 변수를 가리킨다.)
    * 따라서 함수 안에서 인자의 값이 변경되면, 인자로 전달된 변수의 값도 함께 변경된다.
* Call by Value (값에 의한 호출)
    * 함수가 호출될 때, 메모리 공간 안에서는 함수를 위한 별도의 임시 공간이 생성, 인자로 전달되는 변수의 값을 복사하여 함수의 인자로 전달한다.
    * 복사된 인자는 함수 안에서 지역적으로 사용되는 local value의 특성을 가진다.
    * 따라서 함수 안에서 인자의 값이 변경되어도, 외부의 변수의 값은 변경되지 않는다.

> Java는 항상 Call by Value! 

<br>

### 인터페이스와 추상 클래스의 차이(Interface vs Abstract Class)
추상 클래스(Abstract Class)
* abstract 키워드로 선언된 클래스
    * 추상 메서드를 최소 한 개 이상 가지고 abstract로 선언된 클래스
        * 최소 한 개의 추상 메서드를 포함하는 경우 반드시 추상 클래스로 선언하여야 한다.
    * 추상 메서드가 없어도 abstract로 선언한 클래스
* 추상 클래스의 구현
    * 서브 클래스에서 슈퍼 클래스의 모든 추상 메서드를 오버라이딩하여 실행가능한 코드로 구현한다.
* 추상 클래스의 목적
    * 객체(인스턴스)를 생성하기 위함이 아니며, 상속을 위한 부모 클래스로 활용하기 위한 것이다.
    * 여러 클래스들의 공통된 부분을 추상화(추상 메서드) 하여 상속받는 클래스에게 구현을 강제화하기 위한 것이다. (메서드의 동작을 구현하는 자식 클래스로 책임을 위임)
    * 즉, 추상 클래스의 추상 메서드를 자식 클래스가 구체화하여 그 기능을 확장하는 데 목적이 있다.
    * 
인터페이스(Interface)
* 추상 메서드와 상수만을 포함하며, interface 키워드를 사용하여 선언한다.
* 인터페이스의 구현
    * 인터페이스를 상속받고, 추상 메서드를 모두 구현한 클래스를 작성한다.
    * implements 키워드를 사용하여 구현한다.
* 인터페이스의 목적
    * 상속받을 서브 클래스에게 구현할 메서드들의 원형을 모두 알려주어, 클래스가 자신의 목적에 맞게 메서드를 구현하도록 하는 것이다.
    * 구현 객체의 같은 동작을 보장하기 위한 목적이 있다.
    * 즉, 서로 관련이 없는 클래스에서 공통적으로 사용하는 방식이 필요하지만 기능을 각각 구현할 필요가 있는 경우에 사용한다.
* 인터페이스의 특징
    * 인터페이스는 상수 필드와 추상 메서드만으로 구성된다.
    * 모든 메서드는 추상 메서드로서, abstract public 속성이며 생략 가능하다.
    * 상수는 public static final 속성이며, 생략하여 선언할 수 있다.
    * 인터페이스를 상속받아 새로운 인터페이스를 만들 수 있다.
        * interface MobilePhone extends Phone { }

* 추상 클래스와 인터페이스의 공통점
    * 인스턴스(객체)는 생성할 수 없다.
    * 선언만 있고 구현 내용이 없다.
    * 자식 클래스가 메서드의 구체적인 동작을 구현하도록 책임을 위임한다.
* 추상 클래스와 인터페이스의 차이점
    * 서로 다른 목적을 가지고 있다.
        * 추상 클래스는 추상 메서드를 자식 클래스가 구체화하여 그 기능을 확장하는 데 목적이 있다. (상속을 위한 부모 클래스)
        * 인터페이스는 서로 관련이 없는 클래스에서 공통적으로 사용하는 방식이 필요하지만 기능을 각각 구현할 필요가 있는 경우에 사용한다. (구현 객체의 같은 동작을 보장)
    * 추상 클래스는 클래스이지만 인터페이스는 클래스가 아니다.
    * 추상 클래스는 단일 상속이지만 인터페이스는 다중 상속이 가능하다.


### String, StringBuilder, StringBuffer
String
  * 새로운 값을 할당할 때마다 새로 클래스에 대한 객체가 생성된다.
  * String에서 저장되는 문자열은 private final char[]의 형태이기 때문에 String 값은 바꿀수 없다.
      * private: 외부에서 접근 불가
      * final: 초기값 변경 불가
  * String + String + String...
      * 각각의 String 주솟값이 Stack에 쌓이고, Garbage Collector가 호출되기 전까지 생성된 String 객체들은 Heap에 쌓이기 때문에 메모리 관리에 치명적이다.
  * String을 직접 더하는 것보다는 StringBuffer나 StringBuilder를 사용하는 것이 좋다.
   
StringBuilder, StringBuffer
  * memory에 append하는 방식으로, 클래스에 대한 객체를 직접 생성하지 않는다.
  * StringBuilder
       * 변경가능한 문자열
       * 비동기 처리
   * StringBuffer
       * 변경가능한 문자열
       * 동기 처리
       * multiple thread 환경에서 안전한 클래스(thread safe)

### 동기화와 비동기화의 차이(Syncronous vs Asyncronous)
동기화(Syncronous)
  * 한 자원에 동시에 접근하는 것 제한, 순차적으로 진행
  * 다음에 실행될 명령은 현재 실행 중인 명령 종료 시까지 대기 (대기시간 버퍼링 발생)
  * 서버와 클라이언트가 주고 받는 것이 동시에 이루어지는 형태
  * 시간적인 동기화가 필요한 곳에 많이 사용
  * Java에서 synchronized 키워드 사용
      * 자바에서 멀티 스레드 접근 제한 키워드

비동기화(Asyncronous)
  * 현재 실행 중인 명령이 종료되지 않아도 다음 명령 실행 가능
   * Callback 함수를 통해 결과 확인
   * ex. Ajax, Thread

### java에서 '=='와 'equals()'의 차이
"=="
  * 항등 연산자(Operator) 이다.
   * 참조 비교(Reference Comparison) ; (주소 비교, Address Comparison)
      * 두 객체가 같은 메모리 공간을 가리키는지 확인한다.
   * 반환 형태: boolean type
  * 모든 기본 유형(Primitive Types)에 대해 적용할 수 있다.
       * byte, short, char, int, float, double, boolean
  
"equals()"
   * 객체 비교 메서드(Method) 이다.
   * 내용 비교(Content Comparison)
      * 두 객체의 값이 같은지 확인한다.
      * 즉, 문자열의 데이터/내용을 기반으로 비교한다.
   * 기본 유형(Primitive Types)에 대해서는 적용할 수 없다.
   * 반환 형태: boolean type





