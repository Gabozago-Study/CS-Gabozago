# [Algorithm] Interview List

### [Q] 시간 복잡도 vs 공간 복잡도
#
시간 복잡도는 특정 크기의 입력을 기준으로 할 때 필요한 연산의 횟수, 공간 복잡도는 프로그램 실행과 완료에 얼마나 많은 공간(메모리)가 필요한지를 판단합니다. 시간 복잡도와 공간 복잡도는 반비례하는 경향이 있어, 보통 알고리즘의 성능을 판단할 때는 시간 복잡도를 위주로 판단합니다. 

<br>


### [Q] Big-O 표기법의 정의와 사용하는 이유
#
복잡도를 나타내는 점근 표기법 중 가장 많이 사용되는 표기법이며, 알고리즘의 효율성을 분석할때 사용합니다.
Big-O 표기법을 사용하는 이유는, 평균을 나타내는 세타 표기법이 가장 이상적이고 정확하지만, 도출하기가 상대적으로 어려워서 알고리즘의 최악의 경우를 판단하면 평균과 가까운 성능으로 예측이 가능하여 Big-O 표기법을 사용합니다.

<br>

### [Q] Greedy 알고리즘 
#
일명, 탐욕법으로 문제 해결 과정에서 순간순간마다 최적이라고 판단한 방식으로 진행하여 답에 도달하는 알고리즘입니다. 문제의 성질이 동일하게 보존되고, 같은 전략을 반복적으로 사용 가능할 때 적용하며, 앞의 선택이 이후의 선택의 영향을 주지 않는 조건, 문제 최종 해결 방법이 부분 문제에 대한 해결 방법과 동일한 조건을 가집니다.

다른 최적해 계산 알고리즘에 비해 적은 비용을 가지고 속도가 빠른 반면, 당장 그 순간의 최적 값을 찾기 때문에 항상 최적 해를 찾는 것은 불가능합니다.

대표적인 그리디 알고리즘 문제로는 주어진 각 동전을 가장 적게 사용해 N원을 만드는 문제, 1이 될 때까지 나누는 문제가 있습니다.

<br>

### [Q] 깊이 우선 탐색(DFS) vs 너비 우선 탐색(BFS)
#
DFS는 루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법. 즉, 넓게(wide) 탐색하기 전에 깊게(deep) 탐색하는 것입니다.

BFS는 루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법. 즉, 깊게(deep) 탐색하기 전에 넓게(wide) 탐색하는 것입니다.

단순 검색속도는 DFS가 BFS보다 느리고 자기 자신을 호출하는 순환 알고리즘의 형태입니다.
모든 노드를 방문 하고자 하는 경우에 DFS를 선택합니다. DES는 스택으로 구현하고, 재귀적으로 동작합니다.
두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 BFS를 선택합니다. BFS는 큐나 인접리스트로 구현하고, 재귀적으로 동작하지 않습니다.

<br>

### [Q] Quick Sort (퀵 정렬)
#
주어진 리스트에서 기준 원소를 선택(pivot)하고 원소보다 작으면 왼쪽으로 크면 오른쪽으로 분할하여 정렬하는 알고리즘입니다. Divide and Conquer 알고리즘을 사용하여 동작합니다. 

(1)피벗을 기준으로 왼쪽에는 피벗보다 작은 수를, 오른쪽에는 피벗보다 큰 수를 놓는다.<br>
(2)피벗을 기준으로 나뉜 두배열에서 각각 피벗을 정해서 (1)과 같이 정리한다.<br>
(3)더 이상 나눌 수 없을 때까지 나눠서 정렬한다.

속도가 빠르고 추가적인 메모리 공간이 필요 없습니다. 그러나 피벗 선택에 따라 성능이 달라질 수 있고, 최악의 경우에는 O(n^2), 평균적으로는 O(n log n)의 시간 복잡도를 가집니다.

<br>

### [Q] Insertion Sort (삽입 정렬)
#
이미 정렬된 파일에 새로운 데이터를 순서에 맞게 삽입시켜 정렬하는 방식으로 두 번째 값부터 시작해 그 앞에 존재하는 원소들과 비교하여 삽입할 위치를 찾아 삽입하는 정렬 알고리즘입니다.

구현이 간단하고 쉬우며 작은 크기의 배열에 효과적입니다. 최선의 경우 O(n)의 성능을 가지지만, 평균적으로는 O(n^2)의 시간 복잡도를 가집니다.

<br>

### [Q] Selection Sort (선택 정렬)
#
선택 정렬은 정렬되지 않은 데이터들에 대해 가장 작은 데이터를 찾아 가장 앞의 데이터와 교환해 나가는 알고리즘입니다.
정렬하고자 하는 배열 안에서 교환하는 방식이므로, 메모리 공간을 추가로 필요로 하지 않는 제자리 정렬입니다.
구현이 간단하고 쉬우며 작은 크기의 배열에 효과적입니다.
평균적으로 O(n^2)의 시간 복잡도를 갖습니다.

<br>

### [Q] Bubble Sort (버블 정렬)
#
버블 정렬은 서로 인접한 두 원소를 비교, 교환하여 정렬하는 알고리즘입니다.
정렬하고자 하는 배열 안에서 교환하는 방식이므로, 메모리 공간을 추가로 필요로 하지 않는 제자리 정렬입니다.
작은 규모의 배열에서 빠른 성능을 보이지만 배열이 이미 정렬된 경우에도 모든 요소를 비교하므로 성능이 떨어집니다. 
평균적으로 O(n^2)의 시간 복잡도를 갖습니다.

<br>
