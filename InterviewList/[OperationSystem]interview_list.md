# Operating System

### [Q] 운영체제 정의
#
응용 프로그램과 하드웨어 사이에서 인터페이스 역할을 하는 시스템 소프트웨어로 하드웨어(CPU, 메모리, 디스크 등)를 관리합니다.

<br>

### [Q] 프로세스 vs 스레드, 비교하여 설명
#
프로세스는 실행중인 프로그램으로 OS로부터 주소 공간, 파일, 메모리 등을 할당받아 실행, 코드/데이터/스택/힙 메모리 영역을 가집니다.
스레드는 프로세스의 독립적인 실행 단위로 프로세스로부터 자원을 할당받아 실행, 프로세스의 코드/데이터/힙 메모리 영역을 공유하고 개별적인 스택을 가집니다. 

<br>

### [Q] 프로세스 제어 블록(Process Control Block, PCB)이란?
#
프로세스 관리 정보를 저장하는 커널의 자료구조 (Data 영역에 존재)입니다. 운영체제는 프로세스를 관리하기 위해 프로세스의 생성과 동시에 고유한 PCB 를 생성하고, 여기에 Process 상태, PC(다음에 수행할 명령어의 주소), CPU 레지스터, CPU 스케줄링 정보, 메모리 관리 정보 등을 저장합니다.

<br>

### [Q] 문맥 교환 (Context Switching)이란?
#
실행 중이던 프로세스를 중단하고 다른 프로세스를 실행할 때 발생하는, 프로세스 사이에서 CPU 제어권이 이동되는 것입니다. 여기서 Context는 CPU에서 프로세스 실행시 필요한 프로세스의 정보(각 프로세스의 PCB에 저장)입니다.

<br>

### [Q] 멀티 스레드 vs 멀티 프로세스, 비교하여 설명
#
멀티 스레드는 하나의 프로세스에 여러 스레드가 자원을 공유하며 작업을 나누어 하는 것입니다. 
멀티 프로세스는 여러 프로세서(CPU)가 여러 작업(Task)을 동시에 처리하는 것입니다. 
멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만, 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제를 안고 있습니다.
반면 멀티 프로세스 방식은 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다는 장점이 있지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 존재합니다.
이 두 가지는 동시에 여러 작업을 수행한다는 점에서 같지만 적용해야 하는 시스템에 따라 적합/부적합이 구분됩니다. 따라서 대상 시스템의 특징에 따라 적합한 동작 방식을 선택하고 적용해야 합니다.

<br>


### [Q] 교착 상태 (Deadlock)의 정의와 발생 조건을 설명
#
둘 이상의 프로세스/스레드가 자원을 점유한 상태에서 서로 다른 프로세스/스레드가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상입니다.

네 가지 발생 조건이 있으며, 이를 모두 만족해야 합니다.
하나의 프로세스/스레드가 자원에 접근할 수 있는 `상호 배제`, 
다른 프로세스/스레드의 자원을 뺏을 수 없는 `비선점`, 
자원을 가진 상태에서 다른 자원을 기다리는 `점유와 대기`, 
순환 형태로 자원을 대기하는 `순환 대기`가 있습니다.

<br>


### [Q] 기아 상태 (Starvation)란?
#
여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스에 영원히 자원 할당이 되지 않는 상태입니다.
이를 해결하기 위해서는 프로세스의 우선 순위를 변경하거나, 요청을 순서대로 처리하는 요청 큐를 사용해야 합니다.

<br>

### [Q] Fragmentation(단편화)의 정의와 종류
#
프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면, 프로세스들이 차지하는 메모리 틈 사이에 사용 하지 못할 만큼의 작은 자유공간들이 늘어나게 되는데, 이것이 `단편화` 입니다. 
단편화에는 외부 단편화와 내부 단편화가 있습니다. 
외부 단편화란 남아있는 총 메모리 공간이 요청한 메모리 공간보다 크지만, 남아있는 공간이 연속적(contiguous)이지 않아 발생하는 현상입니다.
내부 단편화는 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비되는 현상입니다.

<br>


### [Q] Paging(페이징)과 Segmentation(세그멘테이션)의 정의와 차이점
#
페이징과 세그멘테이션은 메모리 관리 기법으로, 프로세스를 불연속적으로 메모리에 할당하는 방식입니다.

페이징은 프로세스를 동일한 크기의 블록으로 나누어 메모리에 할당합니다. 이 블록을 페이지라고 합니다. 페이지는 고정된 크기를 갖고 있으며, 메모리를 이 크기로 잘라서 사용합니다. 페이지 테이블을 사용하여 가상 주소를 물리 주소로 변환합니다. 하지만 페이징은 블록 내부에 사용되지 않는 공간이 있을 수 있습니다.

반면에 세그멘테이션은 프로세스를 서로 다른 크기의 논리적 단위로 나누어 메모리에 할당합니다. 이 단위를 세그먼트라고 합니다. 세그먼트는 프로세스의 논리적인 단위로 정의된 영역입니다. 세그멘테이션은 세그먼트 테이블을 사용하여 가상 주소를 물리 주소로 변환합니다. 하지만 세그멘테이션은 할당된 세그먼트들 사이에 사용되지 않는 공간이 생길 수 있습니다.

<br>

### [Q] Swapping(스와핑)기법 이란?
#
메모리의 관리를 위해 사용되는 기법입니다. round-robin 과 같은 스케줄링의 다중 프로그래밍 환경에서 CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치(e.g. 하드디스크)로 내보내고, 다른 프로세스의 메모리를 불러 들일 수 있습니다.

<br>

### [Q] Round Robin (라운드 로빈)의 정의와 장점, 주의할 점은?
#
현대적인 CPU 스케줄링 방법으로, 각 프로세스는 동일한 크기의 할당 시간(time quantum)을 갖게 됩니다.
할당 시간이 지나면 프로세스는 선점당하고 ready queue 의 제일 뒤에 가서 다시 줄을 섭니다.

이는 공정한 스케줄링이라 할 수 있으며 CPU 사용시간이 랜덤한 프로세스들이 섞여있을 경우에 효율적입니다.
하지만 설정한 time quantum이 너무 커지면 먼저 온 순서대로 처리하는 FCFS 스케줄링 알고리즘과 같아지고, 너무 작아지면 잦은 `문맥 교환(context switch)` 로 overhead 가 발생합니다. 그렇기 때문에 적당한 time quantum을 설정하는 것이 중요합니다.
