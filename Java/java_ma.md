# JAVA

### Java
- Java는 객체지향 언어이며 JVM을 통해 어떤 운영체제에서도 동일하게 실행되며 가비지 컬렉터에 의해 자동으로 메모리를 관리한다. 또한 다양한 오픈소스 라이브러리와 API를 지원받을 수 있으며 멀티스레드를 지원한다. 

### OOP (Object Oriented Programming : 객체 지향 프로그래밍)
   - 자바는 객체 지향 프로그래밍을 지원한다. 데잍터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식으로 설계에 많은 시간이 소요되며 처리 속도가 다른 프로그래밍 패러다임에 비해 상대적으로 느리다. 하지만 코드의 모듈화, 재사용성, 유지 보수성을 높이는데 도움이 되며, 클래스, 상속, 다형성 등의 개념을 활용한다. 

- **Encapsulation 캡슐화**
	- 관련된 데이터와 메서드를 하나의 단위로 묶어 캡슐화한다. 객체는 내부의 세부 구현을 숨기고 필요한 인터페이스만 노출하여 사용자가는 공개된 정보에만 접근이 가능하고(Information Hiding) 객체를 쉽게 이해하고 사용할 수 있다. 

- **Inheritance 상속**
	- 클래스들 간에 상속 관계를 형성할 수 있다. 부모 클래스의 특성과 동작을 자식 클래스가 상속받아 재사용 할 수 있으며, 새로운 기능을 추가하거나 기존 기능을 변경할 수 있다. 코드의 재사용 측면, 계층적인 관계 생성, 유지 보수성 측면에서 중요하다. 
	- 상속의 특성
    	- 오버라이딩을 제공하여 상속된 일부 메서드를 재정의할 수 있다. 
        - 다중 상속이 불가능 하다.
        - final 클래스는 상속 할 수 없으며 final 메소드는 재정의할 수 없다. 
        - 부모 클래스에서 private 접근 제한을 갖는 필드와 메서드는 상속 대상에서 제외된다. 또한 부모 클래스와 자식 클래스가 다른 패키지에 존재한다면 default 접근 제한을 갖는 필드와 메소드도 상속 대상에서 제외된다. 

- **Polymorphism 다형성**
	- 다형성은 사용 방법은 동일하지만 다양한 객체를 이용해서 다양한 실행 결과가 나오도록 하는 것으로 대표적으로 오버로딩과 오버라이딩이 있다. 

- **Abstraction 추상화**
	- 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려 내는 것으로 이를 기반으로 구체적인 클래스를 정의할 수 있다. 

### Java 컴파일 과정
Runtime Data Area 할당 -> 자바 컴파일러(Java Compiler)가 자바 소스파일을 컴파일 -> 컴파일된 바이트 코드를 JVM의 클래스로더(Class Loader)에게 전달 -> Class Loader를 통해 로딩 -> 클래스 로더는 동적로딩(Dynamic Loading)을 통해 필요한 클래스들을 JVM의 메모리에 로드 -> Execution Engine으로 실행
- Execution Engine 방식
    - 인터프리터 : 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행. 하나하나의 실행은 빠르나, 전체적인 실행 속도가 느리다
    - JIT Compiler : 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 이후에는 해당 메서드를 더이상 인터프리팅 하지 않고, 바이너리 코드로 직접 실행하는 방식으로 전체적인 실행속도는 인터프리팅 방식보다 빠르다. 
    
### JVM Java Virtaul Machine 자바 가상 머신 
- Java 프로세스는 JVM이라는 가상 시스템에서 실행된다. 이와 같은 구조는 컴파일된 Java 클래스 파일(bytecode)를 다양한 OS 환경에서 실행 가능하게 해준다.
- 자바 바이트 코드(Java bytecode)란 자바 가상 머신이 이해할 수 있는 언어로 변환된 자바 소스 코드를 의미한다. 이러한 자바 바이트 코드의 확장자는 .class이다. 자바 바이트 코드는 자바 가상 머신만 설치되어 있으면, 어떤 운영체제에서라도 실행될 수 있다.
- **JVM**
![](https://velog.velcdn.com/images/leema0927/post/0a226eef-334e-4b53-8424-b7cd33837dc1/image.png)


### Java의 메모리 영역 (Runtime Data Area)
- 모든 자바 프로그램은 자바 가상 머신(JVM)을 통해서 실행된다. 자바 프로그램이 실행되면, JVM은 운영 체제로부터 해당 프로그램을 수행할 수 있도록 필요한 메모리를 할당받는다. 이렇게 할당받은 메모리를 JVM은 메모리 공간을 효율성을 높이기 위해 메모리 공간을 용도에 따라 다음과 같이 여러 영역으로 구분하여 나누서 관리한다.
- **Runtime Data Area**
![](https://velog.velcdn.com/images/leema0927/post/76e62e57-7e1b-4cf5-b043-30b5059ab5fc/image.png)

- **Method Area 메서드 영역**
	메서드 영역은 JVM이 시작할 때 생성되고 모든 스레드가 공유하는 영역입ㅂ니다. 메소드 영역에는 코드에서 사용되는 클래스들을 클래스 로더로 읽어 클래스별로 정적 필드와 상수, 메서드 코드, 생성자 코드 등을 분류해서 저장한다. 

- **Heap Area 힙 영역**
	힙영역은 객체와 배열이 생성된느 영역이다. 여기에 생성된 객체와 배열은 JVM 스택 영의 변수나 다른 객체의 필드에서 참조한다. 만일 참조하는 변수나 필드가 없다면 의미 없는 객체가 된기 때문에 JVM에서는 이것을 쓰레기로 취급하고 Garbage Collector를 실행시켜 자동으로 제거한다. 

- **JVM Stack JVM 스택**
	JVM 스택은 메서드를 호출할 때마다 프레임을 추가하고 메서드가 종료되면 해당 프레임을 제거하는 동작을 수행한다. 프레임 내부에는 로컬 변수 스택이 있는데 기본 타입 변수와 참조 타입 변수가 추가 되거나 제거 된다. 스택 영역에 변수가 생성되는 시점은 초기화가 될 때 , 즉 최초로 변수에 값이 저장 될 때며 변수는 선언된 블록안에서만 스택에 존재하고 블록을 벗어나면 스택에서 제거된다. 


### Garbage Collection 가비지 컬렉션
가비지 컬렉션(GC, Garbage Collection)는 Java 프로세스에서 더 이상 사용하지 않는 메모리를 자동으로 해제 해주는 JVM의 작업이다. Java Runtime시 Heap 영역에 저장되는 객체들은 따로 정리하지 않으면 계속헤서 쌓이게되어 OutOfMemmory Exception(OOME)이 발생할 수 있다. 이를 방지하기 위하여 JVM에서는 주기적으로 사용하지 않는 객체를 수집하여 정리하는 GC를 진행한다.


### Overloading vs Overriding 
- **Overloading 오버로딩**
같은 이름을 가진 메서드를 여러개 두는 것을 의미한다. 메서드 타입, 매개변수 유형, 개수등으로 여러개를 둘 수 있다. 

- **Overriding 오버라이딩**
주로 메서드 오버라이딩을 말하며 상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의 하는 것을 미한다. 매개 변수를 달리하는 생성자를 여러개 선언하는 것은 생성자 오버라이딩이라고 한다. 

- **Overloading vs Overriding**
오버라이딩은 상속 관계에서 부모 클래스의 메서드를 자식 클래스에서 재정의 하는 것이고, 오버로딩은 같은 클래스 내에서 메서드 이름은 동일하지만 매개변수 목록이 다른 여러 개의 메서드를 정의하는 것이다. 이 두개념을 활용하여 다형성을 구현하고 유연하고 확장가능한 코드를 작성할 수 있다.      


### Access modifiers 접근 제어자
- 변수나 메서드의 사용 권한은 다음과 같은 접근 제어자를 사용하여 설정할수 있다. 
![](https://velog.velcdn.com/images/leema0927/post/43dd3116-44f7-4bac-a948-29ebfeafc4d3/image.png)
- 클래스와 인터페이스를 다른 패키지에서 사용하지 못하도록 막을 때 사용하며 객체 생성을 막기 위해 생성자를 호출하지 못하게 하거나 필드나 메소드를 사용하지 못하도록 막아야 하는 경우에도 사용한다. 


### Instance 멤버와 Static 멤버
- **Instance 멤버**
객체를 생성한 후 사용할 수 있는 필드와 메서드를 말하는데 이들을 각각 인스턴스 필드, 인스턴스 메소드라고 한다. 
- **Static 멤버**
클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메서드를 말한다. 정적 필드와 정적 메서드라고 부르며 선언 시 static 키워드를 추가적으로 붙이면 된다. 


### Getter/Setter
필드는 외부에서 접근할 수 없도록 막고(private) 메소드는 공개해서 외부에서 메소드를 통해 필드에서 접근하도록 유도한다. 필드의 값을 외부로 리턴해주는 메소드를 Getter라고 하고 외부에서 갑슬 받아 필드를 변경하는 메소드를 Setter라고 한다.     

                          
### final 키워드와 Constant Value 상수
- **final 필드**
초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정 할 수 없다. final 필드의 초기값을 주는 방법은 필드 선언시와 생성자에서 주는 방식이 있으며 초기화가 되지 않았다면 컴파일 에러가 발생한다. 
- **Constant Value 상수**
불변의 값을 저장하는 필드를 자바에서는 상수라고 부르며 static final 로 선언한다. 
- **final 필드 vs Constant Value**
final 필드는 한 번 초기화 되면 수정할 수 없는 필드이지만 상수라고 부르지는 않는다. 불변의 값인 상수는 객체마다 저장할 필요가 없는 공용성을 띠고 있으며 여러가지 값으로 초기화 될 수 없기 때문이다. final 필드는 객체마다 저장되고 생성자의 매개값을 통해서 여러가지 값을 가질 수 있기 때문에 상수가 될 수 없다. 

 
### Abstract Class vs Interface

- **Abstract Class 추상 클래스**
하위 클래스에서 구현될 추상적인 기능이 포함된 클래스로 공통된 필드와 메소드의 이름을 통일할 목적으로 사용된다. 추상 클래스는 선언 시 abstract  키워드를 붙여야만 하며 객체화가 불가능하고 상속을 통해서만 자식 클래스를 만들 수 있다.
- **Abstract method 추상 메소드**
	- 추상 클래스 내에 정의되는 선언 부분만 있고 구현 부분이 없는 메소드로 추상 클래스를 상속한 하위 클래스에서 구현을 강제화하여 재정의(Overriding)을 하도록 한다.
	- 공통적인 필드와 메소드를 추상 클래스에 모두 선언해두고 다른 점만 실체 클래스에 선언하면 작성 시간을 절약할 수 있다. 

- **Interface 인터페이스**
	- 인터페이스는 개발 코드와 객체가 서로 통신하는 접점 역할을 하며 인터페이스는 추상 메소드와 상수만 가진다.
	- 개발 코드가 직접 객체의 메소드르 호출하는 대신 중간에 인터페이스를 두는 이유는 개발 코드를 수정하지 않고 사용하는 개체를 변경 할 수 있도록 하기 위해서 이다. 인터페이스는 하나의 객체가 아니라 여러 객체들과 사용이 가능하므로 어떤 객체를 사용하는냐에 따라서 실행 내용과 리턴값이 다를 수 있다. 

- **Abstract Class vs Interface**
추상 클래스와 인터페이스는 선언만 있고 구현 내용이 없다는 점과 자식 클래스가 메서드의 구체적인 동작을 구현하도록 하여 결합도를 낮춘다는 공통점이 있지만 그 목적이 다르다는 차이가 있다. 추상 클래스는 메서드 오버라이딩을 통한 기능의 구현과 확장에 목적을 둔다면 인터페이스는 필수적으로 동작되어야 할 기능의 규격을 잡아주는 역할을 한다. 또한 추상클래스의 경우 다중 상속이 불가능하지만 인터페이스는 다중 구현이 가능하다.


### Exception 예외
- **Exception 예외**
사용자의 잘못된 조작 또느 개발자의 잘못된 코딩으로 인해 발생하는 프로그램 오류로 예외가 발생되면 프로그램은 곧 바로 종료된다는 점에서는 에러와 비슷하지만 예외 처리를 통해 프로그램을 종료하지 않고 정상 실행 상태가 유지되도록 할 수 있다는 차이가 있다. 자바에서는 예외가 발생할 가능성이 높은 코드를 컴파일 할 때 예외 처리 유무를 확인하며 만약 예외 처리 코드가 없다면 컴파일이 되지 않는다.  

- **Exception 일반 예외**
컴파일러 체크 예외라고도 하며 프로그램 실행 시 예외가 발생할 가능성이 높기 때문에 자바 소스를 컴파일하는 과정에서 해당 예외 처리 코드가 있는지 검사한다. 만약 예외 처리 코드가 없다면 컴파일 오류가 발생한다. 

- **Runtime Exception 실행 예외**
컴파일러 넌 체크 예외라고도 하며 실행 시 예측할 수 없이 갑자기 발생하기 때문에 컴파일하는 과정에서 예외 처리 코드가 있는지 검사하지 않는다. 오로지 개발자의 경험에 의해서 예외 처리 코드를 작성해야한다. 

- **Exception Class 예외 클래스**
자바에서는 예외를 클래스로 관리한다. JVM은 프로그램을 실행하는 도중에 예외가 발생하면 해당 예외 클래스로 객체를 생성하고 예외 처리 코드에서 예외 객체를 이용할 수 있도록 해준다. 모든 예외 클래스는 java.lang.Exception 클래스를 상속 받는다. 
	- NullPointExeption : 자바 프로그램에서 가장 빈번하게 발생하는 실행 예외로 객체가 없는 상태에서 객체를 사용하려고 할 때 발생한다. 
	- ArrayIndexOutOfBoundsException : 배열에서 인덱스 범위를 초과할 경우 발생한다. 
	- NumberFormatException : 숫자로 변활 될 수 없는 문자가 포함되어 있을 때 발생한다. 
	- ClassCastException : 클래스를 다른 타입으로 변환할 수 없을 때 발생한다. 

- **예외 처리 코드 **
	- try-catch-finally 블록 : 생성자 내부와 메소드 내부에서 작성되어 일반 예외와 실행 예외가 발생 할 경우 예외 처리를 할 수 있도록 해준다. 
	- throws 키워드 : 메소드 선언부 끝에 작성되어 메소드에서 처리하지 않은 예외를 호출한 곳으로 떠넘겨 호출한 곳에서 예외 처리를 하도록 한다. 
 

### 컬렉션 프레임워크
자바는 자료구조를 사용해서 객체들을 효율적으로 추가, 삭제, 검색 할 수 있도록 인터페이스와 구현 클래스를 제공한다. 주요 인터페이스로는 List, Set, Map이 존재한다. 
- ![](https://velog.velcdn.com/images/leema0927/post/ce7614f3-52c9-46df-bf79-0c6656628381/image.png)


- **List 컬렉션**
	배열과 비슷하게 객체를 인덱스로 관리한다. 배열과의 차이점은 저장 용량이 자동으로 증가하며 객체를 저장할 때 자동 인덱스가 부여된다는 점으로 추가,삭제,검색을 위한 다양한 메소드들이 제공된다.  
	- ArrayList, Vector, Linked List

- **Set 컬렉션**
저장 순서가 유지되지 않기때문에 인덱스가 존재하지 않으며 객체를 중복해서 저장할 수 없다. 
	-  HashSet, LinkedHashSet, TreeSet

- **Map 컬렉션**
키와 값으로 구성된  Map.Entry 객체를 저장하는 구조를 가지고 있다. 키는 중복 저장 될 수 없지만 값은 중복 저장이 가능하다. 만약 기존에 존재하는 동일한 키가 있다면 새로운 값으로 대체된다. 
	- HashMap, HashTable, LinkedHashMap, Properties, TreeMap

### Generics 제너릭
데이터형을 일반화 한다(Generalize) 라는 의미로 클래스 또는 메소드에서 사용하는 데이터형을 미리 지정하는 방법이다. 데이터 형식 불일치 문제를 컴파일 과정에서 예방할 수 있다.

### Thread 스레드
- **Thread**
프로세스 내에서 실행되는 흐름의 단위로 한 프로세스는 하나 이상의 스레드를 가지고 스레드를 동시에 실행할 수 있다. 이러한 실행 방식을 멀티스레드(multithread)라고 하며 자바는 이러한 멀티 스레드를 지원한다.
- **Process vs Thread**
	- Process는 하나 이상의 Thread로 구성되어 각 Thread가 다양한 기능을 작동시킨다.
	- Process는 서로간에 Memory를 공유하지 않지만 Thread는 공유한다.
- **MultiThread Scheduling**
Thread는 여러 일을 동시에 주기적으로 처리 해 줄 수 있으나 제어가 어렵다는 문제가 있다. 기본적으로 Thread가 Round Robin 방식을 사용하기 때문이다. 즉, 먼저 시작했어도 더 늦게 끝날 수 있다. 이러한 Thread를 제어하기 위해 다양한 방법을 사용하고 있다.

### Syncronous vs Asyncronous
- **Sychronized 동기**
동기화란 내 작업이 끝나기 전에 아무도 접근하지 못하게 막는 다는 의미로 Thread는 Thread간 Memory Share가 가능하기 때문에 발생할 수 있는 데이터의 간섭,오염을 막을 때 사용한다.
- Blocking 방식
- **Asyncronous 비동기**
비동기는 동시에 똑같이 진행되지 않는다는 뜻으로 작업들의 요청과 응답의 타이밍이 같지 않아도 된다는 것이다. 현재 실행 중인 명령이 종료되지 않아도 다음 명령 실행 가능하다.
- Non-Blocking 방식

### Serialization 직렬화
- 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 데이터 변환하는 기술과 바이트로 변환된 데이터를 다시 객체로 변환하는 기술(역직렬화)
- 같은 자바 시스템에서의 데이터 전송, 저장에 최적화 되어있다. 
