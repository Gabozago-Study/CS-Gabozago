# Database

### DBMS
  * 데이터베이스를 관리하고 운영하는 소프트웨어
    * 정의 : DB 구조 (테이블, 속성) 정의
    * 조작 : DB 연산(삽입, 수정, 삭제, 검색) 처리
    * 제어 : 데이터 무결성, 일관성, 접근 권한, 동시성 제어    
  * 구조적 질의 언어 (Structure Query Language)를 통해 삽입,삭제, 수정 조회 등을 수행
  * 응용 프로그램들이 데이터베이스에 접근할 수 있는 인터페이스를 제공하고 복구기능과 보안성 기능을 제공하여 사용자에게 편리한 DB 조작을 가능하게 함

<br>

### SQL
  * DDL(Data Definition Language 데이터 정의어) :
    * 데이터베이스 구조를 정의, 수정, 삭제하는 언어
    * CREATE, DROP, ALTER
  * DML(Data Manipulation Language 데이터 조작어):
    * 조회,삽입,수정,삭제와 같은 데이터 관리를 위한 언어
    *  SELECT, INSERT, UPDATE, DELETE 
  * DCL(Data Control Language 데이터 제어어):
    * 사용자 관리 및 관리, 접근 권한을 다루기 위한 언어
    * COMMIT, ROLLBACK, GRANT, REVOKE

<br>

### RDBMS VS NoSQL
  * RDMS (Relational Database Management System)
    * 관계형 데이터베이스 관리 시스템으로 데이터를 2차원 테이블 형태로 표현
    * 관계를 맺고 모여있는 테이블들의 집합체
    * 테이블 간의 관계에서 서로의 칼럼을 기준으로 Join이 가능
    * 정해진 스키마에 따라 데이터를 저장하기 때문에 명확한 데이터 구조 보장
    * 시스템이 커질수록 Join문이 많은 복잡한 쿼리가 필요하여 성능 저하
    * MySQL, Oracle 등
    
  * NoSQL (Not Only SQL)
    * 비 관계형 데이터베이스로 Key-Value, Document, Big Tavble, Graph 방식으로 데이터를 관리
    * 테이블간 관계를 정의하지 않음
    * 관계가 없기 때문에 Join이 불가능하고 트랜젝션을 지원하지 않음
    * 데이터의 일관성이 보장되지 않기 때문에 중복으로 저장된 데이터마다 업데이트가 필요
    * Redis, MongoDB

  * RDMS는 명확한 데이터 구조를 보장하지만 스키마 추후 변경이 번거롭고 어렵다. 또한 시스템이 커질 경우 Join문이 많은 복잡한 쿼리가 만들어질 수 있으며 성능 향상을 위해 서버의 성능을 향상 시켜야 하므로 비용이 크게 증가할 수 있다 . 그에 비해 No-SQL은 스키마가 없기때문에 자유로운 데이터 구조를 갖고 데이터 분산이 용이하다는 장점이 있다. 하지만 데이터의 중복이 발생할 수 있으며 데이터 구조 결정이 어려울 수 있다.

<br>

### ERD
  * ERD (Entity Relationship Diagram)는 데이터베이스를 구축할 때 가장 기초적인 뼈대로 릴레이션 간의 관계들을 정의한 것
  * 시스템의 요구사항을 기반으로 작성되며 ERD를 기반으로 데이터베이스를 구축
  * 관계형 구조로 표현할 수 있는 데이터를 구성하는데 유용하지만 비정형 데이터를 충분히 표현할 수 없음
 
<br>
 
### KEY 
  * 테이블 간의 관계를 명확하게 하고 검색, 정렬 시 튜플을 구분하는 기준이 되는 속성
  * 종류
    * 기본키 Primary Key : 유일성과 최소성을 만족하는 키
    * 후보키 Candidate key : 유일성과 최소성을 만족하지만 기본키로 선택되지 못한 키
    * 슈퍼 키 Super Key : 유일성을 만족하지만 최소성은 만족하지 못하는 키
    * 외래 키 Foreign Key : 다른 테이블의 기본키를 참조하는 값으로 관계 식별에 사용되는 키

<br>

### 데이터베이스 무결성
  * 데이터의 정확성, 일관성, 유효성이 유지되는 것
  * Entity Intergrity 개체 무결성 (기본키 제약조건)
    * 기본키(Primary Key)는 테이블 내에 오직 하나의 값만 존재해야 하며 Null 값이 올 수 없음
  * Referentail Intergrity 참조 무결성 (외래키 제약조건)
    * 외래키(Foreign Key)는 상위 테이블에 반드시 존재하는 값이거나 Null이어야 함
    * 참조 관계에 있는 두 테이블의 데이터가 항상 일관된 값을 갖도록 유지
  * Domain Intergrity 도메인 무결성
    * 필드의 무결성을 보장하기 위한 것 특정 속성의 값이 그 속성이 정의된 도메인에 속한 값이어야 함

<br>

### Index
  * Index란 테이블을 처음부터 끝까지 검색하지 않고 인덱스를 검색하여 해당 자료의 테이블을 엑세스 할 수 있도록 하는 자료구조 
  * 별도의 메모리 공간에 Key-Value형태로 데이터의 물리적인 주소화 함께 저장
  * 항상 정렬된 상태를 유지하기 때문에 원하는 값을 빠르게 검색할 수 있지만 데이터 삽입, 삭제, 수정시에는 속도가 느림
  * 데이터가 많거나 Join이 많은 경우에 적합하며 데이터의 삽입/삭제/갱신이 잦은 경우에서는 불필요

<br>

### View
  * 하나의 가상 테이블로 물리적으로 존재하지 않음 
  * 복잡한 쿼리를 통해 얻을 수 있는 결과를 간단하게 얻을 수 있음
  
<br>

### Trigger
  * 특정 테이블에 대한 이벤트에 반응해 자동으로 동작되도록 작성된 프로그램으로 사용자가 직접 호출하지 않고 데이터베이스에서 자동적으로 호출

<br>

### 트랜잭션
  * 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위
  * ACID 특징
    * 원자성(Atomicity) : "All or Nothing"으로 모든 작업이 수행 되거나 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되지 않음을 보장
    * 일관성(Consistency) :  트랜잭션 실행 전 후로 일관성 보장
    * 고립성(Isolation)  : 각각의 트랜잭션은 독립적으로 수행
    * 지속성(Durability) : 트랜잭션 완료후의 데이터를 영구적으로 보존
  * 격리 수준
    * SERIALIZABLE : 한 트랜잭션이 commit 될떄까지 다른 트랜잭션은 CRUD 불가
    * REPEATABLE_READ : 조회중인 데이터를 다른트랜잭션에서  UPDATE 불가
    * READ_COMMITTED : COMMIT 된 데이터만 조회 가능
    * READ_UNCOMMITTED : 다른 트랜잭션에서 커밋되지 않은 데이터도 접근 가능

<br>

### DBLock
  * DB Lock은 데이터의 무결성을 보장하기 위해 트랜잭션 처리의 순차성을 보장하는  방법
  * Shared Lock 공유락
    * 데이터를 읽을 때 사용
    * 데이터를 다른 사용자가 동시에 읽을 수 있도록 하지만 변경은 불가능
  * Exclusive Lock 베타락
    * 데이터를 변경할 때 사용
    * 트랜잭션 완료시 까지 어떤 접근(읽기, 쓰기)도 허용하지 않음

<br>

### Blocking 
  * Lock들의 경합이 발생하여 특정 프로세스의 작업이 진행되지않고 멈춘 상태

<br>

### DeadLock 교착상태 
  * 트랜젝션 간 각각 가지고 있는 리소스의 Lock을 획득하려고 할 때 발생으로 자원이 사용가능 해 질때 까지 무한 대기인 상태

<br>

### 이상현상
  * 테이블 내의 데이터들이 불필요하게 중복되어 테이블 조작시 발생되는 데이터 불일치 현상
  * 종류
    * 삽입 이상 (Insertion Anomaly) : 원하지 않는 자료가 삽입되거나 Key가 없어서 삽입하지 못하는 이상 현상
    * 삭제 이상 (Deletion Anomaly) : 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로 원하지 않는 정보 손실이 발생하는 이상 현상
    * 갱신 이상 (Update Anomaly) :일부만 변경하여 데이터가 불일치하는 모순, 또는 중복되는 튜플이 존재하게 되는 이상 현상

<br>

### Nomarlization 정규화
  * 데이터베이스의 중복을 제거하고 무결성을 유지하기 위해 데이터를 구조화하는 작업
  * 이상현상을 제거하고 저장 공간을 효율적으로 사용
  * 정규화의 종류
    * 제 1 정규화 (1NF) : 모든 도메인은 원자 값으로만 구성되도록 분해
    * 제 2 정규화 (2NF) : 기본키가 아닌 모든 속성들이 기본키에 완전 함수 종속을 만족하도록    
    * 제 3 정규화 (3NF) : 이행적 함수 종속을 제거하도록 분해
    
> <b> 완전 함수 종속 <b/> <br>
> 기본키의 부분 집합이 다른 값을 결정하지 않도록 하는 것 

> <b> 이행적 함수 종속 <b/> <br> 
> A -> B, B -> C 일 때 A -> C 성립

<br>

### Denomarlization 역정규화
  * 정규화는 이상현상을 최소화하기 위해 테이블을 쪼개는 작업이지만 지나친 정규화는 쿼리를 복잡하게 만들고 성능을 저하될 수 있으므로 이를 방지하여 전반적인 성능을 향상시키기 위함
  * 테이블이 단순해지고 관리 효율성이 증가되나 데이터의 일관성이나 무결성이 저장되지 않을 수 있음

<br>

### Join
  * 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것
  * 종류
    * Inner Join 내부 조인 : 양쪽 테이블의 두행이 모두 일치하는 행이 있는 데이터만 출력
    * [Left/Outer/Full] Outer Join : 한쪽에는 데이터가 있고 한쪽에는 없는 경우, 데이터가 있는 쪽의 내용을 전부 출력하는 방법

<br>

### DELETE vs TRUNCATE vs DROP
  * DELETE : 조건에 해당하는 데이터를 삭제, Rollback 가능 
  * TRUNCATE : 테이블 구조를 제외한 모든 데이터를 삭제, 테이블 자체를 삭제(DROP) 후 재생성(CREATE)의 개념으로 Rollback 불가능
  * DROP : 테이블 자체를 완전히 삭제, Rollback 불가능

<br>

### JDBC (Java Databse Connectivity)
  * JAVA 프로그램이 Database와 연결 되어 데이터를 주고 받을 수 있게 해주는 프로그래밍 인터페이스로 응용 프로그램과 DBMS간의 통신을 중간에서 번역해주는 역할

<br>

### Optimizer 옵티마이저
  * SQL을 가장 빠르고 효율적으로 수행할 최적의 처리 경로를 생성해주는 DBMS 내부의 핵심 엔진
  * 시스템 통계정보를 활용하여 각 실행계획의 예상 비용을 산정한 후 각 실행계획을 비교해서 최고의 효율을 가지고 있는 실행계획을 판별한 후 그 실행계획에 따라 쿼리를 수행
  * 종류
    * 규칙 기반 옵티마이저 : 실행 속도가 빠른 순으로 규칙을 먼저 세워두고 우선순위가 앞서는 방법을 채택
    * 비용 기반 옵티마이저 : 행 계획을 세운 뒤 비용이 최소한으로 나온 실행 계획을 수행

