# Database

### DB를 사용하는 이유
#
파일 시스템의 문제를 해결하기 위해 사용
* 확장성이 좋음: 파일 시스템은 OS 종속적
* 중복 최소화, 보안성, 계속적 변화에 대한 적응: 파일 시스템은 데이터 중복, 비일관성, 검색 등의 문제 존재
* DB는 원자적 갱신, 동시성 제어, 데이터 보호, 백업 및 회복 등의 여러 데이터 관리 기능을 통해 데이터를 편하게 관리할 수 있음
  
<br/>

### DBMS와 SQL
#
데이터베이스 관리 시스템(DataBase Management System)이란 데이터베이스의 데이터에 접근하여 사용할 수 있도록 해주는 SW
* 정의: DB 구조 정의(테이블, 속성)
* 조작: DB 연산 처리(수정, 삭제, 검색)
* 제어: 데이터 무결성 및 일관성 유지, 접근 권한 부여, 동시성 제어

SQL(Structured Query Language)은 구조적 질의 언어로, 해당 질의 언어를 통해 데이터베이스를 제어하고 관리할 수 있다.
* 종류
  * DDL(Data Definition Language):
데이터베이스 구조를 정의, 수정, 삭제하는 언어이며 create, alter, drop 등이 있다.
  * DML(Data Manipulation Language):
데이터베이스 내의 자료 검색, 삽입, 갱신, 삭제를 위한 언어로 select, delete, update, insert가 있다.
  * DCL(Data Control Language):
데이터에 대해 무결성을 유지, 병행 수행 제어, 보호와 관리를 위한 언어로 commit, rollback, grant, revoke가 있다.

  
<br/>

### 테이블, 행, 열, 도메인
#
테이블
* 행과 열로 이루어진 데이터의 집합
  
행
* 테이블을 구성하는 데이터 셋으로 튜플이나 레코드라고 불림
* 한 객체에 대한 정보를 가짐

열
* 테이블을 구성하는 데이터 셋으로 속성이라고 불림
  
도메인
* 데이터베이스 필드에 채워질 수 있는 값들의 집합
  

> Q. **테이블 vs 스키마** <br>
> 스키마는 데이터베이스의 데이터 구조. <br>
> 테이블, 열, 데이터 유형, 인덱스 등의 정의를 포함.<br>
> 테이블은 행과 열로 구성된 데이터 집합.

<br/>

### 뷰(View)
#
하나 이상의 테이블에서 유도된, 메모리에 물리적으로 존재하지 않는 가상 테이블
* 특정 사용자로부터 특정 속성을 숨기는 기능으로 뷰를 정의하여 그 뷰를 테이블처럼 사용
* 인덱스를 가질 수 없고, 뷰의 정의를 변경할 수 없음
* 테이블의 기본키를 포함하여 정의 시, 삽입/삭제/갱신 가능

<br/>


### 키
#
검색, 정렬 시 튜플을 구분하는 기준이 되는 속성 (Attribute)

**특징**
* 유일성: 키로 튜플을 유일하게 식별할 수 있음
* 최소성: 튜플을 구분하는데 꼭 필요한 속성들로만 구성
  
**종류**
* Super key (슈퍼키) : 유일성 O, 최소성 X
* Candidate key (후보키) : 유일성 O, 최소성 O, 기본 키로 사용할 수 있는 속성들
* Primary key (기본키) : 후보 키 중에서 선정된 키. 유일성 O, 최소성 O, 중복값과 Null값 가질 수 없음(개체 무결성)
* Alternate Key (대체키) : 후보 키에서 기본키를 뺀 모든 후보 키
* Foreign Key (외래키) : 다른 테이블의 Primary key를 참조하는 컬럼
  
<br/>

### 무결성 제약조건
#
데이터의 정확성과 일관성을 유지하고 보증하는 것

개체 무결성
* 기본키로 설정된 컬럼은 고유한 값을 가지며 NULL허용 X
  
참조 무결성
* 외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일
* 참조 관계에 있는 두 테이블의 데이터가 항상 일관된 값을 갖도록 유지하는 것

도메인 무결성
* 특정 속성의 값이 그 속성이 정의된 도메인에 속한 값이어야 한다는 규정
  
    ex) 주민등록번호에 알파벳 입력되면 도메인 무결성 깨진 것

고유 무결성
* 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 그 속성값은 모두 달라야 하는 제약조건

    ex) 학생 릴레이션(테이블)에서 테이블 정의시 '이름' 속성에는 중복된 값이 없도록 제한했다면, '이름' 속성에는 중복된 이름이 있어서는 안됩니다.

NULL 무결성
* 특정 속성값에 NULL 이 올 수 없다는 조건이 주어진 경우, 그 속성값은 NULL 값이 올 수 없다는 제약조건

키 무결성
* 한 릴레이션(테이블)에는 최소한 하나의 키가 존재해야 한다는 제약 조건

<br/>

### 관계
#
테이블 간의 상호작용을 기반으로 설정되는 여러 테이블 간의 논리적 연결을 말하며 주로 외래키(foreign key)를 통해 위 관계를 명시

1:1 관계 (일대일)
* 하나의 레코드가 다른 테이블의 레코드 한 개와 연결된 경우
* 다른 테이블의 레코드 한 개에만 연결돼야 하므로 자주 사용되진 않음

1:N 관계 (일대다)
* 하나의 레코드가 다른 테이블의 서로 다른 여러 개의 레코드와 연결된 경우
* 가장 많이 사용되는 관계

N:M 관계 (다대다)
* 관계를 가진 양쪽 테이블에서 1:N 관계를 가진 경우
* 1:N, 1:M 이라는 관계를 갖는 테이블 두개로 나눠서 설정

<br/>


### 트랜잭션
#
데이터베이스의 상태를 변화시키는 하나의 원자적인/논리적인 작업 단위로 작업의 완전성을 보장한다.
 * Lock과 유사한 기능을 하지만 Lock은 동일한 자원을 요청할 경우 한 시점에는 하나의 커넥션만 변경하는데에 반해 트랜잭션은 논리적인 작업의 쿼리의 개수와 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장

**주의사항**
 * 최소한의 코드에 적용하는 것이 좋음
 * DB 커넥션의 수는 제한적 -> 커넥션이 부족해 대기할 수 있음
  
<br/>

### ACID 라는 4가지 특성을 만족

원자성(Atomicity)
 * 만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.

일관성(Consistency)
 * 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.

고립성(Isolation)
 * 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.

지속성(Durability)
 * 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.

<br/>

### DB Lock 
#
데이터의 일관성과 무결성을 유지하기 위해 Lock을 사용한다. Lock은 트랜잭션 처리의 순차성을 보장해주는 기능을 제공하며, 하나의 트랜잭션이 완벽하게 끝날때까지 다른 요청을 막는다.

**종류**
* 공유락(Shared Lock)(=Read Lock): 
  * 데이터를 읽을때 사용하는 Lock
  * Select에 의해 설정
  * 리소스를 다른 사용자가 동시에 읽을 수 있게 하되 변경은 불가능하다. 
  * 여러 공유락이 동시에 적용될 수 있다.
* 배타락(Exclusive Lock)(=Write Lock): 
  * 데이터를 변경할 때 사용하는 Lock
  * 하나의 트랜잭션이 완료될때까지 유지되며, 배타락이 끝날때까지 어떠한 접근도 허용되지 않는다.
  * INSERT, UPDATE, DELETE에 의해 설정

<br/>

### 블로킹 (Blocking)
#
Lock 간의 경합(Race Condition)이 발생하여 특정 Transaction이 작업을 진행하지 못하고 멈춰선 상태를 말한다. 
공유락끼리는 블로킹이 발생하지 않지만, 배타락은 블로킹을 발생시킨다.

<br/>

### 데드락 (Dead Lock)
#
두 트랜잭션이 각각 Lock을 설정하고, 서로의 Lock에 접근하여 값을 얻어오려고 할때 서로의 Lock으로 인해 양쪽 트랜잭션이 영원히 처리되지 않는 상태이다. 
상대방 Lock이 끝나야 원하는 데이터를 가져오는데 바라보고 있는 서로의 Lock이 같은 상태가 되다보니 영원히 끝나지 않은 상황이 발생하게된다.

**해결 방안**

* Dead Lock이 감지되면 둘 중 하나의 트랜잭션을 강제 종료한다.
  * 실제로, Oracle 에서는 데드락이 감지되면 한쪽 Transaction을 강제로 풀어버린다. 이렇게 되면 하나의 트랜잭션A의 마지막 실행 내용에 오류가 발생되고 커밋이 발생되도록 유지한다. 또다른 트랜잭션 B는 아직 대기중이며, 트랜잭션 A의 커밋을 기다린다.

* Dead Lock 방지를 위해 접근 순서를 동일하게 하는 것이 중요하다. 접근 순서 규칙을 정할 필요가 있다.

<br/>

> ### 블로킹 vs Dead Lock
> 블로킹한 트랜잭션이 끝나면 블로킹은 언젠가 반드시 사라진다. 하지만 데드락은 서로가 서로에게 블로킹을 걸었기 때문에 상대 트랜잭션이 끝나기만을 서로 기다리다가 계속해서 끝나지 않는다.


<br/>


