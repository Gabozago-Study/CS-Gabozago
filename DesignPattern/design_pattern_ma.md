# Design Pattern

### Design Pattern
# 
* 모듈의 세분화된 역할이나 모듈들 간의 인터페이스 구현 방식을 설계할때 참조할 수 있는 전형적인 해결 방식
*  SOLID 원칙을 적용하여 소프트웨어의 유연성, 재사용성, 확장성을 높이기 위해 고안된 구현 방법들의 집합

### SOLID 원칙
#
* SRP (Single Responsibility Principle 단일 책임 원칙): 하나의 클래스는 하나의 기능 또는 책임에만 집중되어 응집도는 높게, 결합도는 낮게 설계 해야 한다는 원칙
  * 응집도 : 모듈 내부의 기능적인 응집 정도
  * 결합도 : 모듈과 모듈간의 상호 결합 정도

* OCP (Open/Closed Principle 개방-폐쇄 원칙): 확장에는 열려 있고, 변경에는 닫혀 있어 기존의 코드를 변경하지 않으면서 새로운 기능(상속)을 추가할 수 있어야 한다는 원칙

* LSP (Liskov Substitution Principle 리스코프 치환 원칙) : 자식 클래스는 최소한 부모 클래스에서 가능한 행위를 수행할 수 있어야 한다는 원칙

* ISP (Interface Segregation Principle 인터페이스 분리 원칙): 클라이언트는 자신이 사용하지 않는 인터페이스에 의존해서는 안 된다. 즉, 인터페이스는 클라이언트에 필요한 기능만 포함해야 한다는 원칙

* DIP (Dependency Inversion Principle 의존 역전 원칙): 의존 관계를 만들 때, 구체적인 구현이 아닌 추상화된 인터페이스에 의존해야 한다는 원칙으로 모든 모듈은 추상화된 인터페이스에 의존

### GoF(Gang of Four) 디자인 패턴
* 소프트웨어 공학에서 가장 많이 사용되는 디자인 패턴 23개로 나눈 것
* 분류 기준
  * 목적에 따른 분류 : 각각의 패턴이 어떤 일을 하기 위한 것인지에 관한 것
    * 생성 : 객체의 생성 과정
    * 구조 : 객체의 합성에 관여
    * 행동 : 객체가 상호작용하는 방법이나 관심사를 분리하는 방법에 관여
  * 범위에 따른 분류 : 패턴을 주로 클래스에 적용하는지, 객체에 적용하는 지 구분하는 것
    * 클래스 패턴 : 클래스와 서브클래스 간의 관련성
    * 객체 패턴 : 객체 간의 관련성  

### GoF 생성패턴
#
* 객체의 생성과 관련된 패턴으로 객체의 인스턴스 과정을 추상화하는 > 방법
* 객체의 생성과 참조 과정을 캡슐화하여 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 받지 않도록 하여 프로그램에 유연성을 더 함
*  종류
>   
> |이름|의도|
> |:---|:---|
> |추상 팩토리(Abstract Factory)| 구체적인 클래스를 지정하지 않고 > 인터페이스를 통해 서로 연관되는 객체들을 그룹으로 표현 |
> |빌더(Builder)| 복합 객체의 생성과 표현을 분리하여 동일한 생성 절차에서도 다른 표현 결과를 만들어낼 수 있음 |
> |팩토리 메소드(Factory Method)|객체 생성을 서브클래스로 위임하여 캡슐화함 |
> |프로토타입(Prototype)| 원본 객체를 복사함으로써 객체를 생성 |
> |싱글톤(Singleton)| 어떤 클래스의 인스턴스는 하나임을 보장하고 어디서든 참조할 수 있도록 함구조 패턴 |
> |

 
### GoF 구조패턴
#
* 클래스나 객체들을 조합해 더 큰 구조로 만들 수 있게 해주는 패턴
* 구조 클래스 패턴은 상속을 통해 클래스나 인터페이스를 합성하고, 구조 객체 패턴은 객체를 합성하는 방법을 정의
* 종류
> 
> |이름|의도|
> |:---|:---|
> |어댑터(Adapter) | 클래스의 인터페이스를 다른 인터페이스로 변환하여 다른 클래스가 이용할 수 있도록 함 |
> |브리지(Bridge) | 구현부에서 추상층을 분리하여 각자 독립적으로 확장할 수 있게 함 |
> |컴포지트(Composite)| 객체들의 관계를 트리 구조로 구성하여 복합 객체와 단일 객체를 구분없이 다룸 |
> |데코레이터(Decorator) | 주어진 상황 및 용도에 따라 어떤 객체에 다른 객체를 덧붙이는 방식 |
> |퍼싸드(Facade)| 서브시스템에 있는 인터페이스 집합에 대해 하나의 통합된 인터페이스(Wrapper) 제공 |
> |프록시(Proxy) | 접근이 어려운 객체로의 접근을 제어하기 위해 객체의 Surrogate나 Placeholder를 제공 |
> |


### GoF 행위패턴
#
* 객체나 클래스의 교류 방법에 대해 정의하는 것 
* 행위 패턴은 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 그들 간의 결합도를 최소화 할 수 있도록 도와준다. 
* 행위 클래스 패턴은 상속을 통해 알고리즘과 제어 흐름을 기술하고, 행위 객체 해턴은 하나의 작업을 수행하기 위해 객체 집합이 어떻게 협력하는지를 기술
* 종류
> 
> |이름|의도|
> |:---|:---|
> |책임 연쇄(Chain of Responsibility) | 청을 받는 객체를 연쇄적으로 묶어 요청을 처리하는 객체를 만날 때까지 객체 Chain을 따라 요청을 전달 |
> |커맨드(Command) | 청을 객체의 형태로 캡슐화하여 재사용하거나 취소할 수 있도록 저장 |
> |인터프리터(Interpreter)| 특정 언어의 문법 표현을 정의 |
> |반복자(Iterator) | 내부를 노출하지 않고 접근이 잦은 어떤 객체의 원소를 순차적으로 접근할 수 있는 동일한 인터페이스 제공 |
> |중재자(Mediator) | 한 집합에 속해있는 객체들의 상호작용을 캡슐화하여 새로운 객체로 정의 |
> |메멘토(Memento) | 객체가 특정 상태로 다시 되돌아올 수 있도록 내부 상태를 실체화 |
> |옵서버(Observer) | 객체 상태가 변할 때 관련 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 함 |
> |상태(State) | 객체의 상태에 따라 동일한 동작을 다르게 처리해야할 때 사용 |
> |전략(Strategy) | 동일 계열의 알고리즘군을 정의하고 캡슐화하여 상호교환이 가능하도록 함 |
> |방문자(Visitor) | 객체의 원소에 대해 수행할 연산을 분리하여 별도의 클래스로 구성함 |
> |
> 

### Singleton pattern 싱글톤 패턴
#
* 클래스의 인스턴스가 오직 하나만 생성되도록 보장하는 패턴으로 여러 곳에서 동시에 같은 인스턴스에 접근할 수 있으며, 자원을 절약하고 전역 상태를 관리하기에 유용
* 장점
  * 자원 절약 : 인스턴스가 하나만 생성되므로 메모리 사용이 최적화하여 메모리 낭비를 방지
  * 전역 상태 관리 : 여러 객체가 동일한 인스턴스에 접근하므로 데이터를 공유하고 공통 상태를 유지하여 전역 상태를 관리하기에 용이  
* 단점
  * 전역 상태 관리의 복잡성 : 인스턴스가 공유되므로, 다른 객체 사이의 의존성이 높아질 수 있고 전역 상태 관리가 복잡해 질 수 있음
  * 유연성 제한 : 다른 인스턴스를 상속하거나 확장하기 어려울 수 있으며 상속이 불가능한 클래스일 경우 싱글톤 패턴을 사용할 수 없음
* 예시
  * 로깅: 로그를 기록하는 기능을 싱글톤으로 구현하여 어디서나 동일한 로그 기능을 사용
  * 데이터베이스 연결 : 데이터베이스 연결을 담당하는 클래스를 싱글톤으로 구현하여 데이터베이스 접근을 관리
  * 애플리케이션 설정 : 애플리케이션 설정 정보를 담당하는 클래스를 싱글톤으로 구현하여 설정 정보에 접근
  
### Template Method Pattern 템플릿 메소드 패턴
#
* 템알고리즘의 구조를 정의하면서 일부 단계를 서브클래스에서 구현하도록 하는 패턴으로 전체 알고리즘의 흐름은 공통으로 유지되고 일부 단계만 서브클래스에서 다르게 구현
* 장점
  * 코드 중복 최소화: 알고리즘의 공통 부분을 부모 클래스에 두기 때문에 코드의 중복을 최소화
  * 확장성: 새로운 알고리즘을 추가하기 쉽고, 기존 알고리즘의 변경이 자식 클래스에 영향이 없음
* 단점
  * 유연성 제한: 일부 단계가 서브클래스에 의해 고정되어 있기 때문에 일부 단계를 동적으로 변경하는 것이 어려움
* 예시 
  * 자바의 추상 클래스를 사용하여 템플릿 메소드 패턴을 구현할 수 있다. 예를 들어, 커피를 만들기 위한 알고리즘을 추상 클래스로 정의하고, 서브클래스에서 각 단계를 구현하여 다양한 종류의 커피를 만들 수 있다.
  
### Factory Method Pattern 팩토리 메소드 패턴
#
* 객체 생성을 캡슐화하는 패턴으로 객체를 생성하는 코드와 실제 객체를 사용하는 코드를 분리하여 유지보수성과 확장성을 높임
* 객체 생성을 처리하는 팩토리(Factory) 클래스를 만들고, 클라이언트 코드는 팩토리를 통해 객체를 생성하므로써 클라이언트는 구체적인 객체 생성 방법을 알 필요 없이 팩토리에 의존하여 객체를 생성하고 사용할 수 있음
* 객체 
  * 생성과 사용 코드 분리 : 객체 생성 코드를 별도의 팩토리 클래스로 분리함으로써 클라이언트 코드가 객체의 구체적인 생성 방법에 대해 알 필요가 없음
  * 유연성과 확장성 : 새로운 객체를 추가하거나 객체 생성 방식을 변경해도 클라이언트 코드에는 영향을 미치지 않으며, 기존 코드를 수정하지 않고도 팩토리 클래스를 확장하여 처리
  * 코드 중복 최소화 : 객체 생성 코드가 여러 곳에 중복되는 것을 방지하여 코드의 중복을 최소화  
* 단점
  * 추가 클래스 필요 : 팩토리 패턴을 사용하려면 별도의 팩토리 클래스를 생성해야 하므로 간단한 객체 생성에서는 너무 많은 클래스를 도입하여 코드의 복잡성이 증가할 수 있음
  * 복잡성 증가 : 팩토리 패턴을 도입하면서 코드의 추상화 수준이 올라갈 수 있음
* 예시
     어떤 애플리케이션에서 다양한 운송 수단(차, 자전거, 비행기 등)을 생성해야 할 때 팩토리 패턴을 사용할 수 있다. 운송 수단을 생성하는 코드를 팩토리 클래스로 추상화하고, 클라이언트 코드에서는 운송 수단을 생성하는데 필요한 세부 내용을 몰라도 된다. 이렇게 함으로써 새로운 운송 수단이 추가되거나 기존 운송 수단의 생성 방식이 변경되어도 클라이언트 코드를 수정하지 않고도 팩토리 클래스만 수정하여 처리할 수 있다.

### Strategy Pattern 전략 패턴
#
* 알고리즘의 유연한 교체를 가능하게 하는 패턴입니다. 이 패턴을 사용하면 실행 중에 알고리즘을 변경할 수 있으며, 각각의 알고리즘을 독립적으로 사용할 수 있음
* 장점
  * 유연한 알고리즘 교체: 클라이언트는 인터페이스를 통해 알고리즘을 사용하므로, 실행 중에 다른 알고리즘으로 교체하는 것이 쉬워 애플리케이션의 유연성과 확장성이 증가
  * 코드 재사용: 각각의 알고리즘을 독립적인 클래스로 구현하기 때문에, 코드를 재사용이 용이
  * 테스트 용이성: 전략 클래스를 인터페이스를 통해 분리하여 개별적으로 테스트 가능
* 단점
  * 클래스 증가: 각각의 알고리즘을 독립적인 클래스로 구현해야 하므로, 전략의 개수가 많을 경우 클래스의 수가 증가할 수 있음 
  * 컨텍스트와 전략 간의 결합: 전략 패턴을 사용하면 컨텍스트와 전략이 느슨하게 결합되긴 하지만, 여전히 컨텍스트는 전략을 명시적으로 선택해야 함
* 예시
  * 정렬 알고리즘 : 수행하는 컨텍스트 클래스가 있고, 이를 실행할 때 사용하는 전략 인터페이스와 다양한 정렬 알고리즘을 구현한 전략 클래스 존재한다.  컨텍스트 클래스는 사용할 정렬 알고리즘을 런타임에 결정하여 다양한 정렬 알고리즘을 유연하게 적용할 수 있다. 


### Observer pattern 옵저버 패턴
#
* 객체 간의 일대다 의존 관계를 정의하는 패턴으로 객체의 상태가 변하면, 이 객체에 의존하는 다른 객체들이 자동으로 알림을 받아 상태 변화를 처리
* 주체(Subject)와 옵저버(Observer)라고 불리는 두 가지 종류의 객체로 구성되며 주체와 옵저버 사이에는 일대다 의존 관계가 형성
  * 주체 : 상태를 가지고 있으며, 이 상태가 변하면 등록된 모든 옵저버에게 알림을 보냄
  * 옵저버 : 주체의 상태 변화를 감시하다가 알림을 받으면 적절한 동작을 수행
* 장점
  * 느슨한 결합: 주체와 옵저버는 서로 독립적으로 변경할 수 있으며, 느슨한 결합을 형성
  * 확장성: 새로운 옵저버를 추가함으로써 기능을 확장 용이
  * 간단한 업데이트 메커니즘: 옵저버 패턴은 변경 사항이 발생할 때마다 옵저버들에게 알림을 보내는 간단한 업데이트 메커니즘을 제공
* 단점
  * 너무 많은 알림 : 주체의 상태가 매우 빈번하게 변경되면, 옵저버들에게 너무 많은 알림을 보내게 되어 성능 저하가 발생
  * 순서 보장 문제 : 옵저버들에 대해 알림을 보낼 때, 알림을 받는 순서가 보장되지 않을 수 있으므로 순서가 중요한 경우에는 주의가 필요
* 예시
  * GUI(그래픽 사용자 인터페이스) 프로그래밍에서 이벤트 처리 : 이벤트가 발생할 때마다 등록된 모든 옵저버에게 알림을 보내어 각각의 옵저버는 해당 이벤트를 처리하므로써 위젯과 이벤트 처리 로직이 분리되어 유연하고 확장 가능한 GUI를 구현할 수 있다.
  
### Proxy Pattern 프록시 패턴
#
* 어떤 객체에 대한 접근을 제어하기 위해 대리자(Proxy) 객체를 사용하는 패턴
*  프록시는 실제 객체와 동일한 인터페이스를 구현하며, 클라이언트는 프록시를 통해 실제 객체에 접근하여 클라이언트와 실제 객체 사이에 중간 계층을 두어 접근을 제어하거나 추가 기능을 제공
* 장점
  * 접근 제어: 프록시를 사용하여 리소스에 접근을 제어. 클라이언트가 실제 리소스에 직접 접근하는 것을 허용하지 않거나, 인증과 같은 접근 제어 로직을 프록시에 구현 가능
  * 성능 향상: 프록시를 이용하여 리소스에 대한 불필요한 연산을 제거
* 단점
  * 코드 복잡성 : 프록시를 도입하면서 중간 계층이 추가되므로 코드가 복잡해질 수 있음
  * 성능 저하 : 프록시 패턴은 실제 리소스에 접근하기 전에 프록시를 거치기 때문에, 약간의 성능 저하가 발생할 수 있음
* 예시
  * 웹 브라우저에서 이미지 로딩지연 : 웹 페이지에 여러 개의 이미지가 있을 때, 이미지를 모두 동시에 로딩하면 성능에 영향을 미칠 수 있으므로 프록시는 실제 이미지를 로딩하지 않고, 웹 페이지를 표시할 때 이미지의 위치만 표시하고 있다가 실제 이미지가 필요한 시점에 로딩한다. 이렇게 함으로써 초기 페이지 로딩 속도를 향상시킬 수 있다.

### Iterator Pattern 이터레이터 패턴
#
* 컬렉션 객체의 내부 구조를 노출하지 않고 요소에 순차적으로 접근하는 방법을 제공하는 패턴으로 클라이언트는 컬렉션의 내부 구조를 알 필요 없이 요소들에게 순차적으로 접근 가능
* 컬렉션 객체와 이터레이터 객체로 구성
  * 컬렉션 객체 : 여러 개의 요소를 포함
  * 이터레이터 객체 : 컬렉션의 요소에 접근하는데 사용되는 인터페이스를 정의
* 장점
  * 컬렉션과 이터레이터의 분리: 이터레이터 패턴을 사용하면 컬렉션 객체의 내부 구조와 요소에 접근하는 방법을 분리하여 컬렉션 객체가 변경되더라도 클라이언트 코드를 수정할 필요가 없음
  * 유연성: 이터레이터 패턴은 서로 다른 컬렉션 객체에 대해 동일한 인터페이스를 제공할 수 있으므로, 다양한 종류의 컬렉션을 사용할 때 유용
  * 순차적 접근: 요소에 순차적으로 접근하기 위해 필요한 메서드를 이터레이터에 정의하므로, 클라이언트는 간편하게 요소들을 순차적으로 처리할 수 있음
* 단점
  * 추가적인 추상화: 이터레이터를 도입하면서 추가적인 추상화 계층이 필요하므로 코드가 복잡해질 수 있음
  * 직접 접근보다 느릴 수 있음: 이터레이터를 통해 접근하는 방식은 직접 컬렉션에 접근하는 것보다 약간의 성능 저하가 발생할 수 있음
* 예시
    Java의 ArrayList와 같은 컬렉션 클래스 : ArrayList의 iterator() 메서드를 호출하면 Iterator 인터페이스를 구현한 이터레이터 객체를 반환한다. 클라이언트는 Iterator 인터페이스를 사용하여 ArrayList의 요소에 순차적으로 접근하고, 컬렉션의 내부 구조를 알 필요 없이 요소들을 처리할 수 있다. 이렇게 함으로써 ArrayList의 내부 구현이 변경되더라도 클라이언트 코드를 수정할 필요가 없다.


### Adapter Pattern 어댑터 패턴
#
* 서로 다른 인터페이스를 가진 두 개의 클래스를 함께 동작하도록 해주는 구조적인 패턴으로 호환되지 않는 인터페이스를 변환하여 하나의 인터페이스를 제공하여 객체들이 함께 작동할 수 있도록 함
* 장점
  * 기존 클래스 재사용 : 기존 클래스를 수정하지 않고 어댑터를 통해 사용 가능
  * 호환성 : 서로 다른 인터페이스를 가진 클래스들 간에 호환성을 확보
* 단점
  * 복잡성: 어댑터를 도입하면 중간 계층이 추가되므로 코드가 복잡해질 수 있음
* 예시 
  * 자바에서는 배열(Array)과 리스트(List)의 인터페이스가 서로 다르지만 어댑터 패턴을 사용하여 배열을 리스트로 변환이 가능하다. Arrays 클래스의 asList() 메서드는 배열을 List 인터페이스에 어댑터 패턴을 적용하여 변환이 가능하다. 


### Composite Pattern 컴포지트 패턴
#
* 컴포지트 패턴은 객체들을 트리 구조로 구성하여 단일 객체와 복합 객체를 동일하게 취급할 수 있도록 하는 구조적인 패턴
* 장점
  * 일관성: 단일 객체와 복합 객체를 동일하게 취급할 수 있으므로 일관성 있는 방식으로 객체들을 다룰 수 있음
  * 유연성: 새로운 객체를 추가하거나 삭제하는 것이 용이
* 단점
  * 복잡성: 트리 구조를 사용하기 때문에 코드가 복잡해질 수 있음
* 예시 
  * 그래픽 디자인 툴에서 그룹과 도형들을 관리하는 구조를 만들기 위해 컴포지트 패턴을 사용할 수 있다.
  


### MVC 패턴
#
* 애플리케이션의 구성 요소를 세 가지 역할로 나누어 설계하는 방법으로 모델(Model), 뷰(View), 컨트롤러(Controller)로 구성되며 각 역할은 명확하게 역할과 책임을 갖고, 서로 독립적으로 동작
  * 모델(Model): 애플리케이션의 데이터와 비즈니스 로직을 담당
  * 뷰(View): 사용자 인터페이스를 표시하고 사용자 입력을 담당
  * 컨트롤러(Controller): 사용자 입력을 처리하고 모델과 뷰를 연결하여 데이터의 흐름을 제어
* 장점
  * 유연성: 각 역할이 분리되어 있으므로, 변경이 발생해도 다른 역할에 영향을 미치지 않고 수정이 가능
  * 유지보수성: 코드의 가독성과 유지보수성이 향상
  * 재사용성: 모델과 뷰, 컨트롤러의 분리로 인해 재사용이 용이
* 단점
  * 복잡성: 대규모 애플리케이션에서는 관리해야 할 코드가 늘어나 복잡해질 수 있음
* 예시
  * 웹 개발에서는 MVC 패턴을 사용하여 데이터베이스에 접근하는 모델, 웹 페이지를 표시하는 뷰, 사용자의 입력을 처리하는 컨트롤러로 애플리케이션을 구성


### MVP 패턴
#
* MVC 패턴의 발전된 형태로, 애플리케이션의 구성 요소를 세 가지 역할로 나누어 설계하며 모델(Model), 뷰(View), 프리젠터(Presenter)로 구성
  * 뷰(View): 사용자 인터페이스를 표시하고, 프리젠터를 통해 사용자의 입력을 전달
  * 프리젠터(Presenter): 사용자 입력을 처리하고 모델과 뷰를 연결하여 데이터의 흐름을 제어
* 장점
  * 유연성: 각 역할이 분리되어 있어 변경이 발생해도 다른 역할에 영향을 미치지 않고 수정이 가능
  * 테스트 용이성: 프리젠터는 인터페이스를 통해 뷰와 모델과 분리되어 있어 단위 테스트가 용이
* 단점
  * 복잡성: 대규모 애플리케이션에서는 관리해야 할 코드가 늘어나 복잡해질 수 있음
* 예시
  * 안드로이드 앱 개발에서는 MVP 패턴을 사용하여 뷰(액티비티)와 프리젠터(프레젠터 클래스)를 분리하여 개발
  
### MVVM 패턴
#
* 플리케이션의 구성 요소를 세 가지 역할로 나누어 설계하는 방법으로 모델(Model), 뷰(View), 뷰모델(ViewModel)로 구성
  * 뷰(View): 사용자 인터페이스를 표시하며, 뷰모델과 바인딩하여 데이터를 표시
  * 뷰모델(ViewModel): 뷰와 모델 사이의 매개체 역할을 하며, 뷰의 상태와 모델의 데이터를 뷰에 반영하고, 뷰에서 발생하는 이벤트를 처리
* 장점
  * 데이터 바인딩: 뷰와 뷰모델의 데이터 바인딩을 통해 UI 업데이트를 간단하게 처리
  * 테스트 용이성: 뷰와 모델의 분리로 인해 단위 테스트가 용이
* 단점
  * 학습 곡선: MVVM 패턴은 처음에는 학습이 필요하며, 복잡한 애플리케이션에서 구현하기 어려울 수 있음
* 예시
  * 개발에서는 MVVM 패턴을 사용하여 Angular 프레임워크에서 컴포넌트와 뷰모델을 분리하여 개발
