# [Database] Interview List

### [Q] DBMS의 특징을 설명
# 
DBMS는 데이터베이스를 관리하고 운영하는 소프트웨어로 응용 프로그램들이 데이터베이스에 접근할 수 있는 인터페이스 제공하고 복구와 보안 기능을 통해 DB 조작을 편리하게 하는 특징이 있습니다. 또한 구조적 질의 언어인 SQL을 통해 삽입, 삭제, 수정, 조회 등을 수행할 수 있습니다.


<br>

### [Q] 테이블과 스키마의 차이점은?
#
테이블은 행과 열로 구성된 데이터 집합이고, 스키마는 테이블, 열, 데이터 유형, 인덱스 등의 정의를 포함하는 데이터베이스의 데이터 구조입니다.

<br>

### [Q] RDBMS VS NoSQL 각각 특징을 설명하고, 어떤 것을 선택해야 하는지?
#
RDBMS는 관계형 데이터베이스를 생성, 수정, 관리하고, 데이터를 2차원 테이블 형태로 표현합니다. 정해진 스키마에 따라 데이터를 저장하기 때문에 명확한 데이터 구조를 보장하고 테이블 간의 관계에서 서로의 칼럼을 기준으로 Join이 가능합니다. 대표적인 예로는 MySQL, Oracle 등이 있습니다.

NoSQL은 Not Only SQL의 약자로, 비관계형 데이터베이스입니다. 관계가 없기 때문에 Join이 불가능하고 트랜잭션을 지원하지 않습니다.
스키마가 없으므로 자유로운 데이터 구조를 가지며 자주 변경되지 않는 데이터를 저장하기 유리하며 읽기, 쓰기가 빠릅니다. 대표적인 예로는 Redis, MongoDB 등이 있습니다.

정리하자면 데이터가 자주 변경되고, 명확한 스키마가 중요하며, 데이터 구조가 극적으로 변경되지 않을 때 시스템에서는 RDBMS를, 
읽기(read) 처리를 자주 하지만 데이터를 자주 변경하지 않고, 막대한 양의 데이터를 다뤄야 하는 시스템에서는 NoSQL을 선택하는 것이 적합합니다.


<br>

### [Q] Redis에 대하여 설명
#
NoSQL 방식 중 Key-Value 형식으로 데이터를 저장하는 인메모리 데이터베이스입니다. 주로 어플리케이션 캐시나 빠른 응답 속도를 가진 데이터베이스로 사용합니다. 

<br>

### [Q] ERD란?
#
데이터베이스를 구축할 때 가장 기초적인 뼈대로 릴레이션 간의 관계들을 정의하는 다이어그램입니다. ERD는 시스템의 요구사항을 기반으로 작성되며 ERD를 기반으로 데이터베이스를 구축합니다. 관계형 구조로 표현할 수 있는 데이터를 구성하는데 유용합니다.


<br>

### [Q] KEY의 정의와 특징을 설명 
#
KEY는 테이블 간의 관계를 명확하게 하고 검색, 정렬 시 튜플을 구분하는 기준이 되는 속성입니다. KEY는 키로 튜플을 유일하게 식별할 수 있는 `유일성`과 튜플을 구분하는데 필요한 최소한의 속성들로만 구성되는 `최소성`을 만족합니다.


<br>

### [Q] 기본키, 외래키, 그와 연관된 무결성에 대한 설명
#
기본키는 유일성과 최소성을 만족하는 키들 중에 특별히 선정된 키로 중복된 값과 Null값을 가질 수 없다는 개체 무결성 제약 조건을 만족해야 합니다.

외래키는 다른 테이블의 기본키를 참조하는 값으로 관계 식별에 사용되는 키입니다. 상위 테이블에 반드시 존재하는 값이거나 Null이어야 한다는 참조 무결성을 만족해야 합니다. 이는 참조 관계에 있는 두 테이블의 데이터의 일관성을 보장합니다.

<br>

### [Q] 테이블 간의 관계의 정의와 종류를 설명
#
테이블 간의 논리적 연결을 의미하며 주로 외래키(foreign key)를 통해 관계를 명시합니다. 
하나의 레코드가 다른 테이블의 레코드 한 개와 연결된 경우는 1:1 관계 (일대일), 하나의 레코드가 다른 테이블의 서로 다른 여러 개의 레코드와 연결된 경우는 1:N 관계 (일대다), 두 개의 테이블이 N:1 관계와 1:M 관계가 합쳐진 경우 N:M 관계 (다대다)라고 정의합니다. 
가장 많이 사용되는 관계는 1:N 관계 (일대다)입니다.

<br>

### [Q] 인덱스(Index)의 정의와 특징을 설명
#
인덱스는 데이터에 대한 검색 성능의 속도를 높여주는 자료 구조로, 별도의 메모리 공간에 Key-Value형태로 데이터와 데이터의 물리적인 주소를 함께 저장합니다.
항상 정렬된 상태를 유지하기 때문에 원하는 값을 빠르게 검색할 수 있고, 데이터 삽입, 삭제, 수정 시 2개의 컬럼을 수정해서 재정렬을 해야하므로 속도가 느린 특징이 있습니다.

인덱스는 데이터가 많거나 Join이 많은 경우에 적합한 반면 데이터의 삽입/삭제/갱신이 잦은 경우에서는 불필요합니다.

<br>

### [Q] Trigger의 정의와 장/단점을 설명
#
트리거는 특정 테이블에서 INSERT, DELETE, UPDATE 같은 DML문이 수행되었을 때, 데이터베이스에서 자동으로 동작하도록 작성된 프로그램입니다.

데이터 무결성을 강화하고, 업무처리를 자동화 해주는 장점이 있지만 트리거 내에서 같은 테이블의 데이터를 변경하는 DML 문을 실행하는 경우 무한 루프에 빠질 수 있습니다. 
예를 들어 Insert 이벤트에 대한 Trigger로 Insert 이벤트가 실행 된다면 무한 루프에 빠지게 됩니다.

<br>

### [Q] 트랜잭션의 정의와 특징
#
트랜잭션은 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위로, ACID라는 네 가지 핵심적인 특징을 갖추고 있습니다.

첫째, `원자성(Atomicity)`은 모든 작업이 성공적으로 수행되거나 문제가 발생하면 어떠한 작업 내용도 반영되지 않음을 보장합니다. 

둘째, `일관성(Consistency)`은 트랜잭션이 완료된 후에도 데이터베이스가 일관된 상태를 유지하는 것을 의미합니다. 

셋째, `독립성(Isolation)`은 각각의 트랜잭션이 서로 독립적으로 실행되어야 함을 의미합니다. 

마지막으로, `지속성(Durability)`은 트랜잭션이 성공적으로 종료된 후에는 해당 작업의 결과가 영구적으로 데이터베이스에 반영되고, 시스템 오류나 장애가 발생하더라도 데이터의 변경 사항이 유지되는 것을 보장합니다.

이렇듯 트랜잭션은 ACID 특징을 준수하여 데이터베이스의 안정성과 신뢰성을 확보하는 중요한 개념입니다.

<br>

### [Q] 데이터베이스 Lock의 정의와 종류를 설명
#
데이터의 일관성과 무결성을 유지하기 위해 Lock을 사용합니다. Lock은 트랜잭션 처리의 순차성을 보장해주는 기능을 제공하며, 하나의 트랜잭션이 완벽하게 끝날때까지 다른 요청을 막습니다.

크게 두 가지 종류로 나눌 수 있는데 먼저 `공유락(Shared Lock)`은 데이터를 읽을때 사용하는 Lock으로, 리소스를 다른 사용자가 동시에 읽을 수 있게 하되 변경은 불가능한 특징이 있습니다.

반면 `배타락(Exclusive Lock)`은 데이터를 변경할 때 사용하는 Lock으로, 하나의 트랜잭션이 완료될때까지 유지되며, 배타락이 끝날때까지 어떠한 접근도 허용되지 않는 특징이 있습니다.

<br>



### [Q] 블로킹과 데드락(DeadLock)의 정의와 차이점을 설명
#
블로킹은 데이터베이스에서 특정 트랜잭션이 다른 트랜잭션에 의해 필요한 자원에 접근할 수 없는 상태를 말합니다. 즉, 하나의 트랜잭션이 자원을 잡고 있으면 다른 트랜잭션이 해당 자원에 접근하지 못하고 기다려야 합니다.

데드락(Deadlock)은 두 개 이상의 트랜잭션이 서로가 점유하고 있는 자원을 기다리며 무한히 대기하는 상태를 말합니다. 각 트랜잭션은 다른 트랜잭션이 점유한 자원을 놓아줄 때까지 아무 작업도 수행할 수 없게 됩니다.

두 현상 모두 데이터베이스에서 동시성 제어에 관련된 문제로 발생하며, 블로킹은 일시적이지만 데드락은 지속적인 상태일 수 있습니다. 이러한 상황들을 방지하기 위해 효율적인 동시성 제어 기법을 사용하여 데이터베이스의 안정성과 성능을 유지하는 것이 중요합니다.

<br>

### [Q] DELETE vs TRUNCATE vs DROP 차이점을 설명
#
DELETE는 테이블에서 특정 행(레코드)을 삭제하는 명령어입니다. 조건을 지정하여 원하는 행을 삭제할 수 있고, 롤백이 가능하며 트리거도 작동하지만, 큰 테이블에서는 느릴 수 있습니다.

TRUNCATE는 테이블의 모든 행을 빠르게 삭제하는 명령어입니다. 조건을 지정할 수 없고, 롤백도 불가능하며 로그를 남기지 않기 때문에 속도가 빠릅니다.

DROP은 테이블의 구조와 데이터를 모두 삭제하는 명령어입니다. 로그를 남기지 않고 바로 삭제되어 복구가 불가능하므로 주의하여 사용해야 합니다.

<br>

### [Q] 정규화에 대해 설명
#
정규화는 관계형 데이터베이스에서 중복을 최소화하고 데이터의 일관성을 유지하기 위해 테이블을 구성하는 과정으로, 데이터를 논리적으로 구조화함으로써 삽입, 갱신, 삭제 시 이상현상을 최소화하고 데이터의 일관성과 정확성을 확보할 수 있습니다. 정규화는 주로 1차 정규형, 2차 정규형, 3차 정규형, BCNF 등으로 구분됩니다. 

<br>

### [Q] 이상현상이란?
#
이상현상은 데이터베이스의 구조나 관계에 오류가 발생하여 정보를 정확하게 검색하거나 조작할 수 없는 상태로 데이터의 무결성과 일관성을 해치는 원인이 됩니다.

의도하지 않은 자료가 삽입되거나 필수적인 속성들이 모두 입력되지 않아 삽입이 제대로 이루어지지 않는 경우 `삽입 이상`, 특정 레코드를 삭제하면 필요한 다른 레코드들도 함께 삭제되는 경우로 원하지 않는 정보 손실이 생기는 경우 `삭제 이상`, 데이터 수정시 일부만 변경되어 데이터가 불일치하는 모순, 또는 중복되는 튜플이 존재하는 경우 `갱신 이상`이 발생합니다.

<br>

### [Q] 반정규화는 어떤 경우에 사용하며, 어떤 특징이 있는지?
#

반정규화는 정규화된 테이블을 다시 합치거나 중복 데이터를 허용하여 성능 최적화와 빠른 데이터 조회를 위해 사용합니다. 정규화로 인해 발생하는 조인 연산의 비용을 줄이거나, 복잡한 쿼리를 단순화함으로써 데이터베이스의 성능을 향상시키는데 도움을 줍니다.

하지만, 반정규화는 데이터 중복으로 인한 데이터 무결성과 일관성을 유지하기 어려울 수 있고 데이터베이스의 용량이 증가할 수으므로, 반드시 적용 전에 잘 검토하여 사용해야 합니다.

<br>